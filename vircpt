#!/usr/bin/python3
"""
    Copyright (C) 2023  Michael Ablassmeier <abi@grinser.de>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
import os
import sys
import logging
import argparse
from getpass import getuser
from libvirt import libvirtError
from libvircpt import client as virt
from libvircpt import checkpoint
from libvircpt import common as lib
from libvircpt.logcount import logCount
from libvircpt import fs
from libvircpt.exceptions import (
    domainNotFound,
    connectionFailed,
)

__version__ = "0.1"


def main() -> None:
    """main"""
    parser = argparse.ArgumentParser(
        description="Libvirt checkpoint swiss army knife",
        epilog=("foo"),
        formatter_class=argparse.RawTextHelpFormatter,
    )

    opt = parser.add_argument_group("General options")
    opt.add_argument("-d", "--domain", required=True, type=str, help="Domain to backup")
    opt.add_argument(
        "-v",
        "--verbose",
        default=False,
        action="store_true",
        help="Debug log",
    )

    user = getuser() or None

    session = "qemu:///system"
    if user != "root":
        session = "qemu:///session"
    opt.add_argument(
        "-U",
        "--uri",
        default=session,
        required=False,
        type=str,
        help="Libvirt connection URI. (default: %(default)s)",
    )
    opt.add_argument(
        "--user",
        default=None,
        required=False,
        type=str,
        help="User to authenticate against libvirtd. (default: %(default)s)",
    )
    opt.add_argument(
        "--password",
        default=None,
        required=False,
        type=str,
        help="Password to authenticate against libvirtd. (default: %(default)s)",
    )
    opt.add_argument(
        "-x",
        "--exclude",
        default=None,
        type=str,
        help="Exclude disk(s) with target dev name (-x vda,vdb)",
    )
    opt.add_argument(
        "-i",
        "--include",
        default=None,
        type=str,
        help="Include only disk with target dev name (-i vda)",
    )
    opt.add_argument(
        "-S",
        "--scratchdir",
        default="/var/tmp",
        required=False,
        type=str,
        help="Target dir for temporary scratch file. (default: %(default)s)",
    )

    sub_parsers = parser.add_subparsers(help="sub-command help", dest="command")
    parser_create = sub_parsers.add_parser("create", help="Create checkpoint")
    parser_create.add_argument(
        "--name", type=str, help="Name of the checkpoint", required=True
    )
    parser_delete = sub_parsers.add_parser("delete", help="Delete checkpoint")
    parser_delete.add_argument(
        "--name", type=str, help="Name of the checkpoint", required=True
    )
    sub_parsers.add_parser("list", help="List checkpoints")
    parser_export = sub_parsers.add_parser("export", help="Export checkpoints via NBD")
    parser_export.add_argument(
        "--name", type=str, help="Name of the checkpoint", required=True
    )
    parser_export.add_argument(
        "-f",
        "--socketfile",
        default=f"/var/tmp/vircpt.{os.getpid()}",
        type=str,
        help="Use specified file for NBD Server socket (default: %(default)s)",
    )
    parser_export.add_argument(
        "-r",
        "--raw",
        default=False,
        action="store_true",
        help="Include full provisioned disk images in export. (default: %(default)s)",
    )
    sub_parsers.add_parser("release", help="Stop exporting.")

    args = lib.argparse(parser)

    counter = logCount()  # pylint: disable=unreachable
    lib.configLogger(args, counter)
    lib.printVersion(__version__)

    try:
        virtClient = virt.client(args)
        domObj = virtClient.getDomain(args.domain)
    except domainNotFound as e:
        logging.error("%s", e)
        sys.exit(1)
    except connectionFailed as e:
        logging.error("Can't connect libvirt daemon: [%s]", e)
        sys.exit(1)

    logging.info("Libvirt library version: [%s]", virtClient.libvirtVersion)

    vmConfig = virtClient.getDomainConfig(domObj)
    diskList = virtClient.getDomainDisks(args, vmConfig)

    if args.command == "create":
        try:
            freezed = fs.freeze(domObj)
            checkpoint.create(args, domObj, diskList)
            if freezed:
                fs.thaw(domObj)
        except libvirtError as e:
            logging.error("Failed to create checkpoint: [%s]", e)
        finally:
            if freezed:
                fs.thaw(domObj)

    if args.command == "delete":
        try:
            cpt = checkpoint.exists(domObj, args.name)
            checkpoint.delete(cpt)
        except libvirtError as e:
            logging.error("Failed to remove checkpoint: [%s]", e)

    if args.command == "list":
        logging.info("List of existing checkpoints:")
        try:
            checkpoint.show(domObj)
        except libvirtError as e:
            logging.error("Failed to list checkpoint: [%s]", e)

    if args.command == "export":
        if virtClient.blockJobActive(domObj, diskList):
            logging.error("Block job already active, can't export")
        else:
            try:
                checkpoint.export(args, domObj, diskList)
            except libvirtError as e:
                logging.error("Failed to export checkpoint: [%s]", e)

    if args.command == "release":
        if virtClient.blockJobActive(domObj, diskList):
            virtClient.stopExport(domObj)

    if counter.count.errors > 0:
        logging.error("Error during checkpoint handling")
        sys.exit(1)

    logging.info("Finished successfully")


if __name__ == "__main__":
    main()
